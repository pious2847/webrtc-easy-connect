
// WebRTC Easy - Minified version
class RTCConnection{constructor(t={}){this.options=t,this.peerConnection=new RTCPeerConnection(t.configuration||{}),this.setupEventListeners(),t.stream&&this.addStream(t.stream)}setupEventListeners(){this.peerConnection.addEventListener("track",t=>{try{this.options.onTrack?.(t)}catch(t){this.handleError(t)}}),this.peerConnection.addEventListener("connectionstatechange",()=>{const t=this.peerConnection.connectionState;this.options.onConnectionStateChange?.(t)}),this.peerConnection.addEventListener("datachannel",t=>{try{this.options.onDataChannel?.(t)}catch(t){this.handleError(t)}})}handleError(t){console.error("WebRTC Error:",t),this.options.onError?.(t)}async createOffer(){try{const t=await this.peerConnection.createOffer();return await this.peerConnection.setLocalDescription(t),t}catch(t){throw this.handleError(t),t}}async createAnswer(t){try{await this.peerConnection.setRemoteDescription(new RTCSessionDescription(t));const e=await this.peerConnection.createAnswer();return await this.peerConnection.setLocalDescription(e),e}catch(t){throw this.handleError(t),t}}async handleAnswer(t){try{await this.peerConnection.setRemoteDescription(new RTCSessionDescription(t))}catch(t){throw this.handleError(t),t}}async addIceCandidate(t){try{await this.peerConnection.addIceCandidate(new RTCIceCandidate(t))}catch(t){throw this.handleError(t),t}}addStream(t){try{t.getTracks().forEach(e=>{this.peerConnection.addTrack(e,t)})}catch(t){throw this.handleError(t),t}}createDataChannel(t,e={}){return this.peerConnection.createDataChannel(t,e)}sendData(t,e){const n=this.peerConnection.createDataChannel(t);"open"===n.readyState?n.send(e):n.onopen=()=>{n.send(e)}}getConnectionState(){return this.peerConnection.connectionState}close(){this.peerConnection.close()}}class MediaHelper{static async getUserMedia(t={video:!0,audio:!0}){try{return await navigator.mediaDevices.getUserMedia(t)}catch(t){throw console.error("Error getting user media:",t),t}}static async getDisplayMedia(t={video:!0}){try{return await navigator.mediaDevices.getDisplayMedia(t)}catch(t){throw console.error("Error getting display media:",t),t}}static stopMediaStream(t){t.getTracks().forEach(t=>t.stop())}}class WebSocketSignaling{constructor(t){this.options=t,this.ws=new WebSocket(t.url),this.messageListeners=[],this.ws.onopen=()=>{t.room&&this.send({type:"join",room:t.room}),t.onOpen?.()},this.ws.onmessage=e=>{try{const n=JSON.parse(e.data);this.messageListeners.forEach(t=>t(n)),t.onMessage?.(n)}catch(t){console.error("Error parsing message:",t)}},this.ws.onclose=()=>{t.onClose?.(),t.autoReconnect&&setTimeout(()=>{this.connect()},t.reconnectDelay||3e3)},this.ws.onerror=e=>{t.onError?.(e)}}send(t){this.ws.readyState===WebSocket.OPEN?this.ws.send(JSON.stringify(t)):this.ws.onopen=()=>{this.ws.send(JSON.stringify(t))}}onMessage(t){this.messageListeners.push(t)}connect(){this.ws.readyState===WebSocket.CLOSED&&(this.ws=new WebSocket(this.options.url))}disconnect(){this.ws.close()}}function useWebRTCReact(t={}){return{localStream:null,remoteStream:null,connection:null,connectionState:"new",error:null,initConnection:async(e=!0,n=!0)=>(console.log("initConnection called with",{videoEnabled:e,audioEnabled:n}),new RTCConnection(t)),startScreenShare:async()=>(console.log("startScreenShare called"),await MediaHelper.getDisplayMedia())}}function useWebRTCVue(t={}){return{localStream:null,remoteStream:null,connection:null,connectionState:"new",error:null,initConnection:async(e=!0,n=!0)=>(console.log("initConnection called with",{videoEnabled:e,audioEnabled:n}),new RTCConnection(t)),startScreenShare:async()=>(console.log("startScreenShare called"),await MediaHelper.getDisplayMedia())}}const WebRTCEasy={RTCConnection:RTCConnection,MediaHelper:MediaHelper,WebSocketSignaling:WebSocketSignaling,useWebRTC:useWebRTCReact,useWebRTCReact:useWebRTCReact,useWebRTCVue:useWebRTCVue};"undefined"!=typeof window&&(window.WebRTCEasy=WebRTCEasy),module.exports=WebRTCEasy;
